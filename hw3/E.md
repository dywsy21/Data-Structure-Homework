# E题思路

对接收到的字符串s进行如下预处理，生成两个哈希表 / unordered_map:
1. 26个哈希表pos，记录每个字符在s中的位置  char -> vector<int>
2. 26个哈希表lower_bound，记录0~1e5中每个整数i对应的index，其中index为使得每个字符s对应的pos[s][index] >= i的最小index  int -> int

lower_bound的目的是为了在每次查询[l, r]字串时，能够快速找到a-z每个字符在该字串中的所有出现位置，从而将查询时间降低到O(1)。

对两个字串均进行一遍这样的操作，然后先检查所有所有在这个两个字串用的字母是否完全相同（还是用lower_bound，如果对应的pos[s][...]不是空的就说明s在这个字串里），然后再检查每个字母出现位置的集合的集合是否一致（用哈希的方法检查，定义unordered_set），即可判断是否同构。

这样，判断一次是否同构就能缩短到O(26 * 26) = O(1)的时间复杂度，而预处理需要O(n)的时间，所以总时间复杂度为O(m + n)。